/****************  PROPRIETARY AND CONFIDENTIAL *******************************/
/***   THE INFORMATION CONTAINED IN THIS FILE IS THE SOLE PROPERTY OF       ***/
/***   PING DSP INC.  ANY REPRODUCTION OR DISTRIBUTION IN PART OR AS A      ***/
/***   WHOLE WITHOUT THE WRITTEN PERMISSION OF PING DSP INC IS PROHIBITED.  ***/
/******************************************************************************/

///
///
/// \mainpage 3DSS-DX Structure API
///
/// This document describes the structure format output by the 3DSS-DX control
/// software over TCP.
///
/// \date 2016 11 09
///
/// \version 0.6
///
/// \author Mark Butowski
///         support@pingdsp.com
///
///
/// \section DESCRIPTION
///
/// Provides C++ data format (structure) definitions for extraction of 
/// 3DSS-DX data from a TCP stream generated by a 3DSS-DX sonar.
///
/// Data is extracted with two successive TCP stream reads. The first
/// read is a header (DxHeader) with a preamble and the data length in bytes
/// to follow on the next stream read.  The second read is the data buffer
/// (DxData) and begins with an identifier (ping count) and timestamps 
/// and then provides offset and count information for 6 included data 
/// sections.  
///
/// The data sections include all sonar settings used during
/// data collection, all ASCII (e.g. NMEA and TSS1) strings acquired during 
/// the ping (+/-100ms) together with port and starboard 
/// sidescan data and sidescan3D data.
/// 
/// Compiler verification functions at the end of this file check
/// for correct structure sizes in bytes.
///
/// \note Only supports little endian machines! (ie x86,x64)
///
/// \section CHANGES
///
/// | Version | Date       | Release Notes                                           |
/// | :------ | :--------- | :------------------------------------------------------ |
/// | 0.1     | 2013.11.29 | initial release                                         |
/// | 0.2     | 2014.02.25 | documentation updates                                   |
/// |         |            | - fixed reversed comments in SidescanPoint3D            |
/// |         |            | - fixed angle comment to downward angles as negative    |
/// | 0.3     | 2014.06.09 | added requested info by 3rd parties and futureproofed   | 
/// |         |            | - now providing pingrate                                |
/// |         |            | - time at the end of the ping (useful for selecting     |
/// |         |            |   ascii sentences that arrived during ping)             |
/// |         |            | - reserved spot for quality factor in 3d points         |
/// |         |            | - reserved spots for more vector data outputs           |
/// |         |            | - added system sample rate                              |
/// |         |            | - changed preamble since the changes are breaking       |
/// | 0.4     | 2015.02.06 | documentation updates                                   |
/// |         |            | - added definition of NMEA sentences typically provided |
/// |         |            |   by the sonar                                          |
/// |         |            | - added definition of TSS1 sentence                     |
/// | 0.5     | 2015.08.25 | added bathymetry points to structure                    |
/// |         |            | - range, angle, amplitude generated from bottom tracked |
/// |         |            |   and binned sidescan-3d data                           |
/// | 0.6     | 2016.11.09 | added recorded to filename and 3DSS control version     |
///
/// \section DEMO
///
/// Below is a simple demo for using this file:
/// 
/// \code
/// int main() {
///
///   using namespace softsonar;
///
///
///   // Create two buffers for the header and the data.
///   char* headerBuf = new char[sizeof(dx::DxHeader)];
///   char* dataBuf = new char[4*1024*1024];
///
///   // Overlay structures over the buffers.
///   dx::DxHeader* header = reinterpret_cast<dx::DxHeader*>(&headerBuf[0]);
///   dx::DxData* data = reinterpret_cast<dx::DxData*>(&dataBuf[0]);
///
///   // Use TcpClient (c++ class that helps with Tcp socket connections)
///   TcpClient client("127.0.0.1", dx::kTcpPort);
///
///   // Connect to localhost on port kTcpPort.
///   bool success = false;
///   success = client.Connect();
///
///   if (!success) {
///     std::cout << "Could not connect!" << std::endl;
///     return -1;
///   }
///
///   // Read pings (infinite).
///   for(;;) {
///
///     // Read the header
///     success = client.Recv(headerBuf, sizeof(dx::DxHeader));
///
///     if (!success || !header->is_preamble_valid()) {
///       std::cout << "Failed to receive header!" << std::endl;
///       return -2;
///     }
///
///     // Read the data
///     success = client.Recv(dataBuf, header->data_count);
///
///     if (!success) {
///       std::cout << "Failed to receive data!" << std::endl;
///       return -3;
///     }
///
///     // Print out the ping id (number)
///     std::cout << "Ping No: " << data->id << std::endl;
///
///     // Print out the time of the ping
///     std::cout << "Time: " << data->time.seconds << "s " 
///               << data->time.nanoseconds << "ns" << std::endl;
///
///     // Get the ASCII sentences from the data and print first one.
///     std::vector<common::AsciiSentence> sentences = data->get_ascii_sentences();
///
///     if (sentences.size() > 0) {
///       std::cout << "First sentence: " << sentences[0].sentence << std::endl;
///     }
///
///     // Get the points from the data and print out the number of points.
///     std::vector<common::SidescanPoint> portSidescan = data->get_port_sidescan_points();
///     std::vector<common::Sidescan3DPoint> portSidescan3 = data->get_port_sidescan3d_points();
///     std::vector<common::SidescanPoint> stbdSidescan = data->get_starboard_sidescan_points();
///     std::vector<common::Sidescan3DPoint> stbdSidescan3 = data->get_starboard_sidescan3d_points();
///
///     std::cout << "No. of points: " << std::setw(10);
///     std::cout << portSidescan.size();
///     std::cout << portSidescan3.size();
///     std::cout << stbdSidescan.size();
///     std::cout << stbdSidescan3.size();
///   
///   }
///
///   // Clean up.
///   client.Disconnect();
///
///   delete[] headerBuf;
///   delete[] dataBuf;
///
///   return 0;
///  
/// }
///
/// \endcode
///
///
///
/// \section LICENSE
///
/// Copyright (c) 2013, Ping Dsp Inc.
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy
/// of this source code directly from Ping DSP Inc, to use and/or modify the 
/// source code with restrictions.  You may use, copy, modify, and merge
/// without limitation.  You may distribute and/or publish the source code only
/// within your organization. You may not distribute and/or publish the source
/// code outisde of your organization.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
/// THE SOFTWARE.
///

///
/// \file pingdsp-3dss.hpp
///
/// \brief 3DSS-DX data interface header file for C++ compilers.
///

#ifndef PINGDSP_3DSS_HPP
#define PINGDSP_3DSS_HPP

///
/// The version of this source file.
///
#define PINGDSP_3DSS_VERSION "0.6"

// Define uint32_t etc...
#include <stdint.h>
#include <vector>

///
/// Typedef and compile time statements which ensure that float is 
/// of compatable with IEEE-754 32bit binary format.
/// std::numeric_traits<float>::is_iec559
/// std::numeric_traits<float>::digits == 24?
/// 
typedef float float32_t;

///
/// Typedef char8_t as a simple UTF-8 character.
///
typedef int8_t char8_t;


namespace softsonar {
namespace common {

  //////////////////////////////////////////////////////////////////////////////
  ///
  /// \struct Timestamp
  ///
  /// \brief Represents the elapsed time since January 1, 1970 12:00 AM.
  ///
  /// A three part structure including seconds, nanoseconds and a set of
  /// status flags.
  ///
  /// \since 0.1  
  ///
  //////////////////////////////////////////////////////////////////////////////
  struct Timestamp {    
  
    ///
    /// Seconds since January 1, 1970 12:00 AM.
    /// 
    uint64_t seconds;
    
    ///
    /// Nanoseconds (remainder from seconds).
    ///
    uint32_t nanoseconds;

    ///
    /// Proprietary status flags.
    ///
    uint32_t flags;
  };


  //////////////////////////////////////////////////////////////////////////////
  ///
  /// \struct SoundVelocity
  ///
  /// \brief Represents the speed of sound values in m/s used by the sonar.
  ///
  /// A two part data structure including bulk and face sound velocities 
  /// expressed in meters per second.
  ///
  /// \since 0.1  
  ///
  //////////////////////////////////////////////////////////////////////////////
  struct SoundVelocity {
    ///
    /// Bulk (average) water column sound velocity in m/s.
    /// 
    float32_t bulk;

    ///
    /// Single point sound velocity at the sonar transducer front face in m/s.
    ///
    float32_t face;
  };
  

  //////////////////////////////////////////////////////////////////////////////
  ///
  /// \struct Gain
  ///
  /// \brief Represents the gain controlling coefficients used by the sonar.
  ///
  /// A three part structure including gain coefficients that vary with range
  /// logarithmically, linearly and not at all. The gain applied for each sample
  /// is determined by the range of the sample and the summation of the gain 
  /// contributions computed from all three coefficients.
  ///
  /// The overall gain in dB is computed as:
  ///   G = constant + linear*Range + logarithmic*log10(Range)
  ///
  /// \since 0.1
  ///
  //////////////////////////////////////////////////////////////////////////////
  struct Gain {
    ///
    /// Coefficient that specifies a constant or fixed gain in dB.
    ///
    float32_t constant;

    ///
    /// Coefficient that specifies a gain that varies linearly with range in 
    /// dB/m.
    ///
    float32_t linear;

    ///
    /// Coefficient that specifies a gain that varies logarithmically with
    /// range in dB/log10(m). 
    ///
    float32_t logarithmic;
  };  

  



  //////////////////////////////////////////////////////////////////////////////
  ///
  /// \struct AsciiSentence
  ///
  /// \brief Represents an ascii sentence received by the sonar.
  ///
  /// A four part structure including a timestamp, an ascii string, a source
  /// identifier, and a port identifier.
  ///
  /// The Ascii string may originate from one of three types received by
  /// the sonar:
  ///     a) NMEA sentence that begins with the '$' character,
  ///	  b) TSS1 sentence that begins with the ':' character,
  ///	  c) TSS3 sentence that begins with the ':' character.
  ///
  /// In all cases the <CR><LF> expected at the end of each sentence received
  /// by the sonar is removed. All other  parts of the sentence received by the 
  /// sonar are preserved and may be parsed as if the sentence originated 
  /// directly from the underlying sensor, including externally connected 
  /// sensors (e.g. MRU or GPS) as well as internal sonar sensors such as the 
  /// internal MRU, and the water temperature sensor.
  /// 
  /// As an example, the internal sonar sensors produce NMEA strings with 
  /// the following NMEA sentence formats:
  ///
  ///	  1. Internal MRU sensor sentence format:
  ///       \code
  ///	      $VNYCM,+YYY.YYY,+PPP.PPP,+RRR.RRR,+mx.mmmm,+my.mmmm,+mz.mmm,
  ///	              +ax.aaa,+ay.yyy,+az.aaa,+gx.gggggg,+gy.gggggg,+gz.gggggg,
  ///	              +TTT.T*cc
  ///        \endcode
  ///	       where:
  ///	         - YYY.YYY	= Yaw in deg
  ///	         - PPP.PPP	= Pitch	in deg
  ///	         - RRR.RRR	= Roll in deg  
  ///	         - TTT.T	  = Temperature in degrees Celsius 
  ///	         - cc	      = Checksum  
  ///
  ///	  2. Internal Water Temperature sensor sentence format:
  ///       \code
  ///	      $PDWTR,sss-ssssssss,hhhhhh,A,ppppp.p,O,ww.ww,C,*,cc
  ///       \endcode
  ///	       where:
  ///	         - ww.ww	= Temperature in degrees Celsius  
  ///	         - cc	    = Checksum
  ///
  ///	  3. $--RMC Sentence, Recommended Miniumu GPS:
  ///		\code
  ///		  $--RMC,hhmmss.ss,A,ddmm.mmm,n,ddmm.mmm,w,x.x,h.h,ddmmyy,m.m,v*cc
  ///       \endcode
  ///          where:
  ///            - hhmmss.ss  = UTC time in hours, minutes, and seconds of the GPS position
  ///            - A          = Status (A = valid, V = invalid)
  ///            - ddmm.mmm   = Latitude in degrees, minutes, and decimal minutes
  ///            - ns         = Latitude location (N = North latitude, S = South latitude)
  ///            - ddmm.mmm   = Longitude in degrees, minutes, and decimal minutes
  ///            - w          = Longitude location (E  = East longitude, W = West longitude)
  ///            - x.x        = Speed over ground in knots
  ///            - h.h        = Track made good, reference to true north
  ///            - ddmmyy     = UTC date of position fix in day, month, and year
  ///            - m.m        = Magnetic variation in degrees
  ///            - v          = Variation sense (E = East, W = West)
  ///
  ///	  4. $--HDT Sentence, Heading True:
  ///		\code
  ///		  $--HDT,x.x,T*cc
  ///       \endcode
  ///          where:
  ///            - x.x  = Current heading in degrees
  ///            - T    = Indicates true heading
  ///
  ///	  5. $--GGA Sentence, Global Positioning System Fix Data:
  ///		\code
  ///		  $--GGA,hhmmss.ss,ddmm.mmmmm,k,ddmm.mmmmmm,l,n,qq,pp.p,aaaa.aa,m,gg.gg,m,sss,rrrr*cc
  ///       \endcode
  ///          where:
  ///            - hhmmss.ss  = UTC time in hours, minutes, and seconds of the GPS position
  ///            - ddmm.mmmmm = Latitude in degrees, minutes, and decimal minutes
  ///            - k          = Latitude location (N = North latitude, S = South latitude)
  ///            - ddmm.mmmmm = Longitude in degrees, minutes, and decimal minutes
  ///            - l          = Longitude location (E  = East longitude, W = West longitude)  
  ///            - n          = Quality indicator
  ///            - qq         = Number of satellites used in position solution
  ///            - pp.p       = Horizontal dilution of precision (HDOP)
  ///            - aaaa.aa    = Antenna altitude, in meters, re: mean-sea-level (geoid)
  ///            - m          = Units of antenna altitude (M = meters)
  ///            - gg.gg      = Geoidal separation (in meters)
  ///            - m          = Units of geoidal separation (M = meters)
  ///            - sss        = Age of differential corrections, in seconds
  ///            - rrrr       = Differential reference station ID  
  ///
  ///	  6. $--VTG Sentence, Track Made Good and Ground Speed:
  ///		\code
  ///		  $--VTG,ttt,T,mmm,M,nnn.nn,N,kkk.kk,K,x*cc
  ///       \endcode
  ///          where:
  ///            - ttt       = True course over ground (COG) in degrees (000 to 359)
  ///            - T         = True course over ground indicator (always 'T')
  ///            - mmm       = Magnetic course over ground in degrees (000 to 359)
  ///            - M         = Magnetic course over ground indicator (always 'M')
  ///            - nnn.nn    = Speed over ground in knots
  ///            - N         = Speed over ground in knots indicator (always 'N')
  ///            - kkk.kk    = Speed over ground in km/h
  ///            - K         = Speed over ground in km/h indicator (always 'K')  
  ///            - x         = Mode  
  ///
  ///	  7. TSS1 Sentence:
  ///		\code
  ///		  :XXAAAASMHHHHQMRRRRSMPPPP
  ///       \endcode
  ///          where:
  ///            - XX       = Horizontal acceleration (hex value), in 3.83 cm/s^2, with a range of zero to 9.81 m/s^2
  ///            - AAAA     = Vertical acceleration (hex value - 2’s complement), in 0.0625 cm/s^2, with a range of –20.48 to +20.48 m/s^2
  ///            - S        = Space character
  ///            - M        = Space if positive; minus if negative
  ///            - HHHH     = Heave, in centimeters, with a range of –99.99 to +99.99 meters
  ///            - Q        = Status Flag
  ///            - M        = Space if positive; minus if negative
  ///            - RRRR     = Roll, in units of 0.01 degrees (ex: 1000 = 10 degrees), with a range of –99.99 to +99.99 degrees
  ///            - S        = Space character
  ///            - M        = Space if positive; minus if negative
  ///            - PPPP     = Pitch, in units of 0.01 degrees (ex: 1000 = 10 degrees), with a range of –99.99 to +99.99 degrees
  ///
  /// \since 0.1  
  ///
  //////////////////////////////////////////////////////////////////////////////
  struct AsciiSentence {
    ///
    /// The sonar time when first character of the sentence was received by 
    /// the sonar.
    ///
    Timestamp timestamp;

    ///
    /// The Ascii sentence beginning with either a '$'or ':' character.
    /// The character array is null terminated without <CR><LF>.
    ///
    char8_t sentence[256];

    ///
    /// An identifier indicating the sonar system origin of the sentence.
    ///
    uint32_t source;

    ///
    /// An identifier indicating the sonar serial port origin of the sentence.
    ///
    uint32_t port;

  };


  //////////////////////////////////////////////////////////////////////////////
  ///
  /// \struct SidescanSettings
  ///
  /// \brief Represents the sidescan settings used by the sonar.
  ///
  /// A three part structure including the sidescan mode, and mode specific 
  /// settings.
  ///
  /// \since 0.1  
  ///
  //////////////////////////////////////////////////////////////////////////////
  struct SidescanSettings {
    ///
    /// The sidescan mode of operation, specified by name. 
    ///
    char8_t mode[32];

    ///
    /// The method of combining array elements for operation in incoherent
    /// mode, specified by name.
    ///
    char8_t incoherent_method[32];

    ///
    /// The vertical sidescan beams used in coherent sidescan mode,
    /// specified as a list of beam names.  
    ///
    char8_t coherent_beams[64];
  };


  //////////////////////////////////////////////////////////////////////////////
  ///
  /// \struct Sidescan3DSettings
  ///
  /// \brief Represents the sidescan-3d settings used by the sonar.
  ///
  /// A four part structure including the sidescan3D settings, smoothing,
  /// tolerance, threshold, and number_of_angles. 
  ///
  /// \since 0.1  
  ///
  //////////////////////////////////////////////////////////////////////////////
  struct Sidescan3DSettings {
    ///
    /// The number of receive samples to include in angle computations.
    ///
    int32_t smoothing;

    ///
    /// The tolerance for non-plane wave arrivals in angle computations.
    ///
    float32_t tolerance;

    ///    
    /// The receive signal level threshold in dB re FS (fullscale) for angle 
    /// computations.
    ///
    float32_t threshold;

    ///
    /// The number of angles to compute at each range step.
    ///
    int32_t number_of_angles;
  };





  //////////////////////////////////////////////////////////////////////////////
  ///
  /// \struct TransmitSettings
  ///
  /// \brief Represents the transmit settings used by the sonar.
  ///
  /// A four part structure including the sonar transmit settings, angle,
  /// power, beamwidth, and pulse.
  ///
  /// \since 0.1  
  ///
  //////////////////////////////////////////////////////////////////////////////
  struct TransmitSettings {    
    ///
    /// The transmit beam angle (direction) in degrees relative to the maximum 
    /// response axis of the transducer. Positive angles are downward.
    ///
    float32_t angle;

    ///
    /// The transmit power as a percentage of maximum.
    ///
    uint32_t power;

    ///
    /// The transmit beamwidth (beampattern) specified by name.
    ///
    char8_t beamwidth[32];

    ///
    /// The transmit pulse waveform specified by name.
    ///
    char8_t pulse[32];
  };  


  //////////////////////////////////////////////////////////////////////////////
  ///
  /// \struct TriggerSettings
  ///
  /// \brief Represents the trigger settings used by the sonar.
  ///
  /// A two part structure including the sonar trigger settings, source and
  /// continuousdutycycle.
  ///
  /// \since 0.1
  ///
  //////////////////////////////////////////////////////////////////////////////
  struct TriggerSettings {
    ///
    /// The trigger source used by the sonar specified by name.
    ///
    char8_t source[32];

    ///
    /// The duty cycle specifying the trigger repetition rate as a fraction of 
    /// the maximum rate for the current sonar range setting. Only applicable
    /// when the trigger source is set to Continuous.
    ///
    float32_t countinuousdutycycle;
  
    ///
    /// Reserved - likely ping rate in the future.
    /// \since 0.3
    ///
    float32_t reserved;
    
  };


  //////////////////////////////////////////////////////////////////////////////
  ///
  /// \struct SidescanPoint
  ///
  /// \brief Represents a sidescan point.
  ///
  /// A two part structure including the sidescan data values, range and 
  /// amplitude.
  ///
  /// \since 0.1
  ///
  //////////////////////////////////////////////////////////////////////////////
  struct SidescanPoint {
    ///
    /// The range in meters to the sidescan data point.
    ///
    float32_t range;

    ///
    /// The amplitude of the sidescan data point. 
    ///
    /// Amplitudes represent the magnitude of the received signal envelope 
    /// after gain and sidescan processing methods are applied.
    ///
    float32_t amplitude;
  };


  //////////////////////////////////////////////////////////////////////////////
  ///
  /// \struct Sidescan3DPoint
  ///
  /// \brief Represents a sidescan 3d point.
  ///
  /// A three part structure including the sidescan3D data values, range,
  /// amplitude, and angle.
  ///
  /// \since 0.1
  ///
  //////////////////////////////////////////////////////////////////////////////
  struct Sidescan3DPoint {
    ///
    /// The range in meters to the sidescan-3D data point.    
    ///
    float32_t range;

    ///
    /// The angle in radians of the sidescan-3D data point. Negative angles
    /// are downward from the maximum response axis of the transducer.    
    ///	
    float32_t angle;

    ///
    /// The amplitude of the sidescan-3D data point after gain and sidescan 3D
    /// processing methods are applied.    
    ///
    float32_t amplitude;
  
    ///
    /// Reserved for a future value, either SNR or quality factor for the point.
    /// \since 0.3
    ///
    float32_t reserved;
  
  };
  
  
  //////////////////////////////////////////////////////////////////////////////
  ///
  /// \struct BathymetryPoint
  ///
  /// \brief Represents a bathymetry point.
  ///
  /// A three part structure including the bathymetry data values, range,
  /// amplitude, and angle.
  ///
  /// \since 0.5
  ///
  //////////////////////////////////////////////////////////////////////////////
  struct BathymetryPoint {
    ///
    /// The range in meters to the bathymetry data point.    
    ///
    float32_t range;

    ///
    /// The angle in radians of the bathymetry data point. Negative angles
    /// are downward from the maximum response axis of the transducer.    
    ///	
    float32_t angle;

    ///
    /// The amplitude of the bathymetry data point after gain and bathymetry
    /// processing methods are applied.    
    ///
    float32_t amplitude;
  
    ///
    /// Reserved for a future value, either SNR or quality factor for the point.
    ///
    float32_t reserved1;
	
    ///
    /// Reserved for a future value, either SNR or quality factor for the point.
    ///
    float32_t reserved2;
	
  
  };
  

} // namespace common

namespace dx {

  //////////////////////////////////////////////////////////////////////////////
  ///
  /// Constants
  ///
  //////////////////////////////////////////////////////////////////////////////

  ///
  /// Tcp port on which the sonar software is listening.
  ///
  const int kTcpPort = 23848;

  ///
  /// Expected preamble for the Dx data.
  ///
  const uint8_t kPreamble[] = { 0x50, 0x49, 0x4e, 0x47,
                                0x27, 0x2b, 0x3a, 0xd8,
                                0x74, 0x2a, 0x1c, 0x33,
                                0xe9, 0xb0, 0x73, 0xb1 };

  //////////////////////////////////////////////////////////////////////////////
  ///
  /// \struct DxParameters
  ///
  /// \brief Represents the parameters at the time of the ping.
  ///
  /// An eleven part structure including all sonar settings in use at the time
  /// the data was acquired. Substructures as defined above are used to group 
  /// settings according to sonar function.
  ///
  /// \since 0.1  
  ///
  //////////////////////////////////////////////////////////////////////////////
  struct DxParameters {
    ///
    /// The sonar range setting.    
    ///
    float32_t range;

    ///
    /// The sonar trigger settings.
    ///
    common::TriggerSettings trigger;

    ///
    /// The sonar sound velocity setting.
    ///
    common::SoundVelocity sound_velocity;

    ///
    /// The sonar port-side receive gain setting.
    ///
    common::Gain port_gain;

    ///
    /// the sonar starboard-side receive gain settings.
    ///
    common::Gain starboard_gain;

    ///
    /// The sonar port-side sidescan settings.
    ///
    common::SidescanSettings port_sidescan;

    ///
    /// The sonar starboard-side sidescan settings.
    ///
    common::SidescanSettings starboard_sidescan;

    ///
    /// The sonar port-side sidescan-3d settings.
    ///
    common::Sidescan3DSettings port_sidescan3d;

    ///
    /// The sonar starboard-side sidescan-3d settings.
    ///
    common::Sidescan3DSettings starboard_sidescan3d;

    ///
    /// The sonar port-side transmit settings.
    ///
    common::TransmitSettings port_transmit;

    ///
    /// The sonar starboard-side transmit settings.
    ///
    common::TransmitSettings stardboard_transmit;

    ///
    /// Temporary reserved bytes and also padding to 8byte boundary.
    /// \since 0.3
    ///
    char8_t reserved[68];
  };
  
  
  //////////////////////////////////////////////////////////////////////////////
  ///
  /// \struct DxSystemInfo
  ///
  /// \brief Contains information specific to this sonar system.
  ///
  /// A ten part structure including information about the sonar.
  ///
  /// \since 0.1  
  ///
  //////////////////////////////////////////////////////////////////////////////
  struct DxSystemInfo {
    ///
    /// A 32 character null terminated string identifying the sonar.
    ///
    char8_t id[32];

    ///
    /// The acoustic frequency of this sonar in Hertz.
    ///
    float32_t acoustic_frequency;

    ///
    /// The sample rate for the sidescan data in Hertz.
    ///
    float32_t sample_rate;

    ///
    /// The maximum ping rate for the sonar in Hertz for the current settings.
    ///
    float32_t maximum_ping_rate;

    ///
    /// The range resolution in meters for the port sidescan data for this ping.
    ///
    float32_t port_sidescan_range_resolution;

    ///
    /// The range resolution in meters for the starboard sidescan data.
    ///
    float32_t starboard_sidescan_range_resolution;

    ///
    /// The range resolution in meters for the port sidescan-3d data.
    ///
    float32_t port_sidescan3d_range_resolution;

    ///
    /// The range resolution in meters for the starboard sidescan-3d data.
    ///
    float32_t starboard_sidescan3d_range_resolution;

    ///
    /// The angle of the port transducer in degrees as mounted in the sonar
    /// housing relative to horizontal and with positive values indicating 
    /// downward.
    ///
    float32_t port_transducer_angle;

    ///
    /// The angle of the starboard transducer in degrees as mounted in the sonar
    /// housing relative to horizontal and with positive values indicating 
    /// downward.
    ///
    float32_t starboard_transducer_angle;

    ///
    /// Temporary reserved bytes and also padding to 8byte boundary.
    ///
    char8_t reserved[60];
  };


  //////////////////////////////////////////////////////////////////////////////
  ///
  /// \struct DxHeader
  ///
  /// \brief The header transmitted before each data structure.
  ///
  /// A two part structure including a unque preamble and the data count in
  /// bytes for the data buffer to follow.  A preamble validation method is
  /// also included.
  ///
  /// \since 0.1  
  ///
  //////////////////////////////////////////////////////////////////////////////
  struct DxHeader {
    ///
    /// A unique 16 byte preamble.
    ///
    uint8_t preamble[16];

    ///
    /// The size of the data structure to follow in bytes.
    ///
    uint32_t data_count;

    ///
    /// Checks and return if the preamble is valid.
    ///
    bool is_preamble_valid() {
      for(int i=0; i < sizeof(preamble); i++) {
        if (preamble[i] != kPreamble[i]) return false;
      }
      return true;
    }
  };


  //////////////////////////////////////////////////////////////////////////////
  ///
  /// \struct DxData
  ///
  /// \brief Represents all data and sonar settings for an entire sonar ping.
  ///
  /// A multi-part function and data structure describing the entire ping.
  /// It includes the data id (ping number), the data timestamp, the range zero
  /// timestamp, the sonar settings, and access functions for retreiving data
  /// from the following substructures:
  ///	  1. Ascii sentences
  ///   2. Port sidescan data points
  ///	  3. Starboard sidescan data points
  ///	  4. Port Sidescan3D data points
  ///	  5. Starboard Sidescan3D data points  
  ///
  /// \since 0.1  
  ///
  //////////////////////////////////////////////////////////////////////////////
  struct DxData {
    ///
    /// The data id (ping number).
    ///
    uint64_t id;

    ///
    /// Time at which the trigger occured.
    ///
    common::Timestamp time;

    ///
    /// The zero range time. (ie the time at which the sonar range=0)
    ///
    /// \note This timestamp, along with the bulk sound velocity and range value,
    ///       allows the exact time to be computed from the range values for any
    ///       sidescan or sidescan3D data point.
    ///
    common::Timestamp time_range_zero;

    ///
    /// The sonar settings in use at the time the data was acquired.
    ///
    dx::DxParameters parameters;

    ///
    /// The sonar system info.
    ///
    dx::DxSystemInfo system_info;
  
  private: /// optionally marked private

    ///
    /// The offset in bytes from the start of the DxData structure to the start 
    /// of the Ascii sentence data section.
    ///
    uint32_t ascii_sentence_offset;
    
    ///
    /// The number of Ascii sentence present.
    ///
    uint32_t ascii_sentence_count;

    ///
    /// The offset in bytes from the start of the DxData structure to the start 
    /// of the port sidescan data section.
    ///
    uint32_t port_sidescan_offset;

    ///
    /// The number of port sidescan points present.
    ///
    uint32_t port_sidescan_count;

    ///
    /// The offset in bytes from the start of the DxData structure to the start 
    /// of the starboard sidescan data section.
    ///
    uint32_t starboard_sidescan_offset;

    ///
    /// The number of starboard sidescan points present.
    ///
    uint32_t starboard_sidescan_count;

    ///
    /// The offset in bytes from the start of the DxData structure to the start 
    /// of the port sidescan-3d data section.
    ///
    uint32_t port_sidescan3d_offset;

    ///
    /// The number of port sidescan-3d points present.
    ///
    uint32_t port_sidescan3d_count;

    ///
    /// The offset in bytes from the start of the DxData structure to the start 
    /// of the starboard sidescan-3d data section.
    ///
    uint32_t starboard_sidescan3d_offset;

    ///
    /// The number of starboard-3d sidescan points present.
    ///
    uint32_t starboard_sidescan3d_count;

    ///
    /// The offset in bytes from the start of the DxData structure to the start 
    /// of the port bathymetry data section.
	  /// \since 0.5
    ///
    uint32_t port_bathymetry_offset;

    ///
    /// The number of port bathymetry points present.
	  /// \since 0.5
    ///
    uint32_t port_bathymetry_count;

    ///
    /// The offset in bytes from the start of the DxData structure to the start 
    /// of the starboard bathymetry data section.
	  /// \since 0.5
    ///
    uint32_t starboard_bathymetry_offset;

    ///
    /// The number of bathymetry sidescan points present.
	  /// \since 0.5
    ///
    uint32_t starboard_bathymetry_count;	

    ///
    /// The offset in bytes from the start of the DxData structure to the start
    /// of the recorded filename which is a null terminated string.
    /// \since 0.6
    ///
    uint32_t recorded_filename_offset;

    ///
    /// The offset in bytes from the start of the DxData structure to the start
    /// of the recorded vesrion which is a null terminated string.
    /// \since 0.6
    ///
    uint32_t recorded_version_offset;

    ///
    /// Added a few reserved bytes to give us the capability to add additional data without
    /// breaking existing code.  Allows for up to 8 additional data spaces.
    /// \since 0.3
    ///
    uint32_t reserved_space[16];
  
    ///
    /// Zero length array (can be omitted).  The first variable length data
    /// section starts here (typically the AsciiSentences, 
    /// ie ascii_sentence_offset should point to this)
    ///
   // uint8_t variable_length_data[];

  public:
    ///
    /// Pointer to the start/first ascii sentence within the structure.
    ///
    const common::AsciiSentence* get_ascii_sentence_ptr() const {
      // TODO: add sanity check on the offset (ie: 0 < offset < 10,000,000)
      //       can be 0 iff count is 0
      using namespace softsonar::common;
      const uint8_t* data = reinterpret_cast<const uint8_t*>(this);
      const uint8_t* head = data + ascii_sentence_offset;
      return reinterpret_cast<const AsciiSentence*>(head);
    }

    ///
    /// Number of ascii sentences present.
    ///
    int get_ascii_sentence_count() const {
      // TODO: add sanity check on the count (ie: 0 <= count < 10,000)      
      return ascii_sentence_count;
    }
    
    ///
    /// Helper method which returns the Ascii sentence data as a std::vector.
    ///
    /// \note Typically a compiler will automatically return value optimize and 
    ///       inline this code.  Hence its recommended to use this std::vector 
    ///       over directly using the ascii_sentence_ptr() and sentence_count().
    ///
    std::vector<common::AsciiSentence> get_ascii_sentences() const {
      using namespace softsonar::common;
      const AsciiSentence* head = get_ascii_sentence_ptr();
      const AsciiSentence* tail = head + get_ascii_sentence_count();
      return std::vector<AsciiSentence>(head, tail);
    }

    ///
    /// Pointer to the start/first port-side sidescan point within the
    /// structure.
    ///
    const common::SidescanPoint* get_port_sidescan_point_ptr() const {
      // TODO: add sanity check on the offset (ie: 0 < offset < 10,000,000)
      //       can be 0 iff count is 0
      using namespace softsonar::common;
      const uint8_t* data = reinterpret_cast<const uint8_t*>(this);
      const uint8_t* head = data + port_sidescan_offset;
      return reinterpret_cast<const SidescanPoint*>(head);
    }

    ///
    /// Number of port-side sidescan points present.
    ///
    int get_port_sidescan_point_count() const {
      // TODO: add sanity check on the count (ie: 0 <= count < 10,000)
      return port_sidescan_count;      
    }

    ///
    /// Helper method to return the port-side sidescan data as a std::vector.
    ///
    /// \note Typically a compiler will automatically return value optimize and 
    ///       inline this code.  Hence its recommended to use this std::vector 
    ///       over directly using the point_ptr() and point_count().
    ///
    std::vector<common::SidescanPoint> get_port_sidescan_points() const {
      using namespace softsonar::common;
      const SidescanPoint* head = get_port_sidescan_point_ptr();
      const SidescanPoint* tail = head + get_port_sidescan_point_count();
      return std::vector<SidescanPoint>(head, tail);
    }

    ///
    /// Pointer to the start/first starboard-side sidescan point within the
    /// structure.
    ///
    const common::SidescanPoint* get_starboard_sidescan_point_ptr() const {
      using namespace softsonar::common;
      const uint8_t* data = reinterpret_cast<const uint8_t*>(this);
      const uint8_t* head = data + starboard_sidescan_offset;
      return reinterpret_cast<const SidescanPoint*>(head);
    }

    ///
    /// Number of starboard-side sidescan points present.
    ///
    int get_starboard_sidescan_point_count() const {
      return starboard_sidescan_count;
    }

    ///
    /// Helper method which returns the starboard-side sidescan points as a
    /// std::vector.
    ///
    /// \note Typically a compiler will automatically return value optimize and 
    ///       inline this code.  Hence its recommended to use this std::vector 
    ///       over directly using the point_ptr() and point_count().
    ///
    std::vector<common::SidescanPoint> get_starboard_sidescan_points() const {
      using namespace softsonar::common;
      const SidescanPoint* head = get_starboard_sidescan_point_ptr();
      const SidescanPoint* tail = head + get_starboard_sidescan_point_count();
      return std::vector<SidescanPoint>(head, tail);
    }
    
    ///
    /// Pointer to the start/first port-side sidescan-3d point within the
    /// structure.
    ///
    const common::Sidescan3DPoint* get_port_sidescan3d_point_ptr() const {
      // TODO: add sanity check on the offset (ie: 0 < offset < 10,000,000)
      //       can be 0 iff count is 0
      using namespace softsonar::common;
      const uint8_t* data = reinterpret_cast<const uint8_t*>(this);
      const uint8_t* head = data + port_sidescan3d_offset;
      return reinterpret_cast<const Sidescan3DPoint*>(head);
    }

    ///
    /// Number of port-side sidescan-3d points present.
    ///
    int get_port_sidescan3d_point_count() const {
      // TODO: add sanity check on the count (ie: 0 <= count < 10,000)
      return port_sidescan3d_count;
    }

    ///
    /// Helper method which returns the port-side sidescan-3d points as a
    /// std::vector.
    ///
    /// \note Typically a compiler will automatically return value optimize and 
    ///       inline this code.  Hence its recommended to use this std::vector 
    ///       over directly using the point_ptr() and point_count().
    ///
    std::vector<common::Sidescan3DPoint> get_port_sidescan3d_points() const {
      using namespace softsonar::common;
      const Sidescan3DPoint* head = get_port_sidescan3d_point_ptr();
      const Sidescan3DPoint* tail = head + get_port_sidescan3d_point_count();
      return std::vector<Sidescan3DPoint>(head, tail);
    }

    ///
    /// Pointer to the start/first starboard-side sidescan-3d point within the
    /// structure.
    ///
    const common::Sidescan3DPoint* get_starboard_sidescan3d_point_ptr() const {
      using namespace softsonar::common;
      const uint8_t* data = reinterpret_cast<const uint8_t*>(this);
      const uint8_t* head = data + starboard_sidescan3d_offset;
      return reinterpret_cast<const Sidescan3DPoint*>(head);
    }

    ///
    /// Number of starboard-side sidescan-3d points present.
    ///
    int get_starboard_sidescan3d_point_count() const {
      return starboard_sidescan3d_count;
    }

    ///
    /// Helper method which returns the starboard-side sidescan-3d points as a
    /// std::vector.
    ///
    /// \note Typically a compiler will automatically return value optimize and 
    ///       inline this code.  Hence its recommended to use this std::vector 
    ///       over directly using the point_ptr() and point_count().
    ///
    std::vector<common::Sidescan3DPoint> get_starboard_sidescan3d_points() const {
      using namespace softsonar::common;
      const Sidescan3DPoint* head = get_starboard_sidescan3d_point_ptr();
      const Sidescan3DPoint* tail = head + get_starboard_sidescan3d_point_count();
      return std::vector<Sidescan3DPoint>(head, tail);
    }

    ///
    /// Pointer to the start/first port-side bathymetry point within the
    /// structure.
	  /// \since 0.5
    ///
    const common::BathymetryPoint* get_port_bathymetry_point_ptr() const {
      // TODO: add sanity check on the offset (ie: 0 < offset < 10,000,000)
      //       can be 0 iff count is 0
      using namespace softsonar::common;
      const uint8_t* data = reinterpret_cast<const uint8_t*>(this);
      const uint8_t* head = data + port_bathymetry_offset;
      return reinterpret_cast<const BathymetryPoint*>(head);
    }

    ///
    /// Number of port-side bathymetry points present.
	  /// \since 0.5
    ///
    int get_port_bathymetry_point_count() const {
      // TODO: add sanity check on the count (ie: 0 <= count < 10,000)
      return port_bathymetry_count;
    }

    ///
    /// Helper method which returns the port-side bathymetry points as a
    /// std::vector.
	  ///
	  /// \note std::vector constructor copies the data out of the structure into a new allocated array
	  /// \since 0.5
    ///
    std::vector<common::BathymetryPoint> get_port_bathymetry_points() const {
      using namespace softsonar::common;
      const BathymetryPoint* head = get_port_bathymetry_point_ptr();
      const BathymetryPoint* tail = head + get_port_bathymetry_point_count();
      return std::vector<BathymetryPoint>(head, tail);
    }

    ///
    /// Pointer to the start/first starboard-side bathymetry point within the
    /// structure.
	  /// \since 0.5
    ///
    const common::BathymetryPoint* get_starboard_bathymetry_point_ptr() const {
      using namespace softsonar::common;
      const uint8_t* data = reinterpret_cast<const uint8_t*>(this);
      const uint8_t* head = data + starboard_bathymetry_offset;
      return reinterpret_cast<const BathymetryPoint*>(head);
    }

    ///
    /// Number of starboard-side bathymetry points present.
	  /// \since 0.5
    ///
    int get_starboard_bathymetry_point_count() const {
      return starboard_bathymetry_count;
    }

    ///
    /// Helper method which returns the starboard-side bathymetry points as a
    /// std::vector.
	  /// \note std::vector constructor copies the data out of the structure into a new allocated array
	  /// \since 0.5	
    ///
    std::vector<common::BathymetryPoint> get_starboard_bathymetry_points() const {
      using namespace softsonar::common;
      const BathymetryPoint* head = get_starboard_bathymetry_point_ptr();
      const BathymetryPoint* tail = head + get_starboard_bathymetry_point_count();
      return std::vector<BathymetryPoint>(head, tail);
    }

    ///
    /// Helper method which returns the recorded filename as a std::string.
    /// 
    /// \since 0.6
    ///
    std::string get_recorded_filename() const {
      if (recorded_filename_offset)
	      return std::string(reinterpret_cast<const char*>(this) + recorded_filename_offset);
      else
        return std::string();
    }

    ///
    /// Helper method which returns the recorded version as a std::string.
    /// 
    /// \since 0.6
    ///
    std::string get_recorded_version() const {
      if (recorded_version_offset)
	      return std::string(reinterpret_cast<const char*>(this) + recorded_version_offset);
      else
        return std::string();
    }
	
  };


} // namespace dx
} // namespace softsonar


//////////////////// COMPILE TIME TESTS ////////////////////////////////////////

namespace softsonar {
namespace common {
  //////////////////////////////////////////////////////////////////////////////
  /// Check that the structs are of correct size.
  /// (i.e. detects any padding)
  //////////////////////////////////////////////////////////////////////////////
  static_assert( sizeof(Gain) == 12, 
    "Gain struct compiled incorrectly!" );

  static_assert( sizeof(SoundVelocity) == 8, 
    "SoundVelocity struct compiled incorrectly!" );

  static_assert( sizeof(Timestamp) == 16, 
    "Timestamp struct compiled incorrectly!" );

  static_assert( sizeof(SidescanSettings) == 128, 
    "SidescanSettings struct compiled incorrectly!" );  

  static_assert( sizeof(Sidescan3DSettings) == 16, 
    "Sidescan3DSettings struct compiled incorrectly!" );  

  static_assert( sizeof(TransmitSettings) == 72, 
    "TransmitSettings struct compiled incorrectly!" );  

  static_assert( sizeof(TriggerSettings) == 40, 
    "TriggerSettings struct compiled incorrectly!" );  

  static_assert( sizeof(AsciiSentence) == sizeof(Timestamp) + 256 + 8, 
    "AsciiSentence struct compiled incorrectly!" );  

  static_assert( sizeof(SidescanPoint) == 8,
    "SidescanPoint struct compiled incorrectly!" );

  static_assert( sizeof(Sidescan3DPoint) == 16,
    "Sidescan3DPoint struct compiled incorrectly!" );
  
} // namespace common

namespace dx {
  //////////////////////////////////////////////////////////////////////////////
  /// Check that the structs are of correct size.
  /// (i.e. detects any padding)
  //////////////////////////////////////////////////////////////////////////////

  static_assert( sizeof(DxParameters) == sizeof(uint32_t) 
                                       + sizeof(common::TriggerSettings)
                                       + sizeof(common::SoundVelocity)
                                       + sizeof(common::Gain)*2
                                       + sizeof(common::SidescanSettings)*2
                                       + sizeof(common::Sidescan3DSettings)*2
                                       + sizeof(common::TransmitSettings)*2
                                       + sizeof(char8_t)*68,
    "DxParameters struct compiled incorrectly!" ); 

  static_assert( sizeof(DxSystemInfo) == 128,
    "DxSystemInfo struct compiled incorrectly!" );

  static_assert( sizeof(DxData) == sizeof(uint64_t) 
                                 + sizeof(common::Timestamp)*2
                                 + sizeof(dx::DxParameters)
                                 + sizeof(dx::DxSystemInfo)
                                 + sizeof(uint32_t)*32,
    "DxData struct compiled incorrectly!" );

} // namespace dx
} // namespace softsonar


#endif // PINGDSP_3DSS_HPP
    